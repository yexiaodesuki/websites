#练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）
如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？
```

好处：
（1）能够减少页表项数量，节省内存开销
（2）提高TLB（Translation Lookaside Buffer）命中率。每个TLB条目能覆盖更大的虚拟地址范围，因此在程序访问大量连续地址时，TLB命中率显著提高，减少了地址转换的开销。
（3）减少页表访问次数。分级页表需要多次内存访问来完成地址转换（每一级都可能引发一次内存访问），而大页页表通常只需一次访问，大幅减少内存访问延迟。
（4）适合大块连续内存分配。对于需要映射大块连续内存的应用（如大数据处理、虚拟机、GPU内存等），一大页可以减少复杂性，提高映射效率。
坏处：
（1）内存浪费（碎片化）。大页粒度意味着分配的内存块可能包含大量未使用的地址空间，导致内存碎片化加剧。对于小数据块或不连续内存访问的应用程序，内存利用率可能显著降低。
（2）不适合小数据场景。如果程序频繁访问的小数据块分散在地址空间中，大页可能会浪费大量不必要的内存，且不会明显提高性能。
（3）灵活性下降。分级页表允许以更细粒度控制内存映射和保护属性，而一大页缺乏这种灵活性。不便于实现复杂的内存管理策略，例如按需分页、内存共享等。
（4）管理复杂度增加。在某些硬件架构中，支持大页可能需要更复杂的页表管理代码和配置。如果需要动态调整页大小，会增加软件实现的复杂性。

```

#challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）
```
设计实现过程：
大部分代码补充部分均与fifo算法一致，但我们需要修改其页面换出的方法。我实现的具体逻辑是触发时钟事件，从而执行lru_tick_event函数，这个函数将会扫描链表中所有的页面，通过页表项中的A位获知是否被访问过。如果被访问过，就将该页面放到链表首部，这样每次从尾部换出页面时就能保证是最久之前被使用的页面了
具体的lru_tick_event函数代码及解释如下：
```c
static int
_lru_tick_event(struct mm_struct *mm)
{ 
    // 获取 LRU 链表的头节点
    list_entry_t *head = (list_entry_t *)mm->sm_priv;
    assert(head != NULL); // 确保链表头节点不为空

    // 从链表的第一个页面开始扫描
    list_entry_t *entry = list_next(head);

    // 遍历整个 LRU 链表
    while (entry != head)
    {
        // 获取与该链表节点相关联的 Page 结构体
        struct Page *page = le2page(entry, pra_page_link);

        // 获取该页面虚拟地址的页表项指针
        pte_t *ptep = get_pte(mm->pgdir, page->pra_vaddr, 0);

        /**
         * 检查页表项中的 A 位（访问位）。
         * 如果 A 位为 1，表示该页面自上次扫描以来有被访问过。
         */
        if ( PTE_A & *ptep )
        {
            // 将页面从链表中删除
            list_del(entry);

            // 将该页面插入到链表的首部（表示它最近被访问过）
            list_add(head, entry);

            // 清除 A 位，重置页面的访问状态
            *ptep &= ~PTE_A;

            // 使该页面的 TLB 条目失效，以确保 A 位的修改生效
            tlb_invalidate(mm->pgdir, page->pra_vaddr);
        }

        // 移动到下一个页面节点
        entry = list_prev(head);
    }

    // 输出日志，表示链表已更新
    cprintf("LRU链表已更新\n");
    return 0; 
}

